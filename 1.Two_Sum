ğŸ’­ Step 1: What do we need to find?
We want to find two different indices in the array such that:

nums[i] + nums[j] = target

ğŸ‘‰ Return the indices of those two numbers.
ğŸ‘‰ It is guaranteed that exactly one solution exists.

ğŸ§° Step 2: What tool (data structure) helps us?
We need:
Fast lookup to check if a number already exists
To remember the index of previously seen numbers

âœ… HashMap is perfect:
Key â†’ number
Value â†’ index of that number

This allows O(1) average lookup time.

ğŸªœ Step 3: Whatâ€™s the step-by-step plan?
(i) Create a HashMap<Integer, Integer>
Stores (number â†’ index) pairs.
(ii) Traverse the array using a loop.
(iii) For each element nums[i]:
Calculate the complement:
complement = target - nums[i].
(iv) Check if the complement already exists in the map:
If yes â†’ we found the pair â†’ return indices.
If no â†’ store the current number and its index in the map.
(v) If the loop ends without finding a pair â†’ throw an exception
(because the problem guarantees a solution).

âœ… Solution:

class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int i = 0;

        while (i != nums.length) {
            int complement = target - nums[i];

            if (map.containsKey(complement))
                return new int[]{i, map.get(complement)};
            else
                map.put(nums[i], i);

            i++;
        }
        throw new IllegalArgumentException("No match");
    }
}


âš¡ Example Walkthrough:
nums = [2,7,11,15], target = 9
i = 0 â†’ complement = 7 â†’ not in map â†’ put (2,0)
i = 1 â†’ complement = 2 â†’ found in map â†’ return {1,0} âœ…

â±ï¸ Complexity Analysis:

Time: O(n) (single pass)
Space: O(n) (HashMap storage)